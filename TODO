-----------------------------------------------------------------------------
-- User Interface

0. Bare Bones.

   You supply:
	type AlexInput
	alexGetChar  :: AlexInput -> Maybe (Char,AlexInput)
	alexPrevChar :: AlexInput -> Char

   Alex supplies:
	type StartCode
	alexScan :: AlexInput		 -- The current input
		 -> StartCode		 -- The "start code"
		 -> Maybe (           	 -- Nothing on error or EOF
			     AlexInput,  -- The remaining input
			     Int,        -- Length of this token
			     action      -- The action (unknown type)
			  )


1. Basic wrapper (startcodes cannot be used).

   You supply:

	actions :: String -> a
	
   Alex supplies:

	alexScanTokens :: String -> [a]


2. Simple monad wrapper with a String input.

   You supply:

        actions :: AlexInput -> Int -> action
	alexEOF :: AlexInput -> action

   Alex supplies:

	type Alex a
	type AlexInput = (AlexPosn,Char,String)
	runAlex :: String -> Alex a -> a
	alexMonadScan :: Alex action
	alexGetStartCode :: Alex Int
	alexSetStartCode :: Int -> Alex ()
	etc.

3. GScan wrapper (same as old Alex).

   You supply:

	actions :: AlexPosn -> Char -> String -> Int -> ((Int,s) -> action)

   Alex supplies:

	data AlexPosn = ...
	alexGScan :: Stop -> s -> String -> action

4. Your own monad...

-----------------------------------------------------------------------------

- Extend to Unicode (32-bit Char)

- Generate a function from String -> [Token]?

- Put in {-# LINE #-} pragmas for token actions

- bug: we throw away the first character of code

- built-in skip for empty tokens

- expand the escape sequences supported

- Prune states that aren't reachable?

- Issues a warning for tokens that can't be generated?

- Info file?
	- start codes
	- accepting states

- Fast/compact lexer table encoding:
	- equivalence classes?

- Improve performance of Alex itself

- Arbitrary predicates on a pattern, eg.

     a*bbb \ { .. an expr .. }

  the question is, what state can the expression get at.  It looks
  like it needs the AlexInput before and after the lexeme, at least,
  and possibly an abstract state passed in?

-----------------------------------------------------------------------------
- performance:
		monads   -O      -g
	words                           0.36
	words            *              0.13
	words            *       *      0.09
	words	*			0.46
	words   *        *              0.19
	words   *        *       *      0.14  (*)

	(+) use unboxed tuples		0.13
	(+) hack to avoid bad transformation 0.12
	(+) simplify accept code (no contexts) 0.11
	(+) fix inlining of check_acc   0.09

        on a longer example:

	        monads    -O      -g
	words 	*	  *	  *	1.02
	words             *       *     1.00

        i.e. monads makes little difference.  This is
        just straight counting of words strictly, using
	an accumulating parameter in both cases.

 - using the ST monad with STRefs instead of a home-grown ST monad
   improves performance:

	haskell.x, lexing lots_of.hs
		old monad :  250M  allocated
		ST  monad :  200M  allocated
	  (using the INLINE [0] trick in alex_scan_tkn in both cases)

	by explicitly eta-expanding check_accs, so it gets inlined properly,
	we get the allocation down to

		ST monad : 95M allocated

	a very small amount of this (3M?) is due to the AlexPosn allocated
        for each character.

